package internalhttp

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/whatafunc/Golang_Otus_Labs/hw12_13_14_15_calendar/internal/storage"
)

// MockLogger implements the Logger interface for testing
type MockLogger struct{}

func (m *MockLogger) Info(msg string) {}

// MockApplication implements the Application interface for testing.
type MockApplication struct {
	events map[int]storage.Event
}

func NewMockApplication() *MockApplication {
	return &MockApplication{
		events: make(map[int]storage.Event),
	}
}

func (m *MockApplication) CreateEvent(ctx context.Context, event storage.Event) error {
	m.events[event.ID] = event
	return nil
}

func (m *MockApplication) GetEvent(ctx context.Context, id int) (storage.Event, error) {
	event, exists := m.events[id]
	if !exists {
		return storage.Event{}, errors.New("event not found")
	}
	return event, nil
}

func (m *MockApplication) ListEvents(ctx context.Context, period storage.Period) ([]storage.Event, error) {
	events := make([]storage.Event, 0, len(m.events))
	for _, event := range m.events {
		events = append(events, event)
	}
	return events, nil
}

func (m *MockApplication) DeleteEvent(ctx context.Context, id int) error {
	if _, exists := m.events[id]; !exists {
		return errors.New("event not found")
	}
	delete(m.events, id)
	return nil
}

func TestServer_HandleCreateEvent(t *testing.T) {
	// Setup
	logger := &MockLogger{}
	app := NewMockApplication()
	server := NewServer(logger, app, ":8080")

	// Test cases
	testCases := []struct {
		name           string
		method         string
		requestBody    CreateEventRequest
		expectedStatus int
		expectedError  bool
	}{
		{
			name:   "successful event creation",
			method: http.MethodPost,
			requestBody: CreateEventRequest{
				ID:          1,
				Title:       "Test Event",
				Description: "Test Description",
			},
			expectedStatus: http.StatusCreated,
			expectedError:  false,
		},
		{
			name:   "missing title",
			method: http.MethodPost,
			requestBody: CreateEventRequest{
				ID:    2,
				Title: "",
			},
			expectedStatus: http.StatusBadRequest,
			expectedError:  true,
		},
		{
			name:           "wrong method",
			method:         http.MethodGet,
			requestBody:    CreateEventRequest{},
			expectedStatus: http.StatusMethodNotAllowed,
			expectedError:  true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create request body
			body, _ := json.Marshal(tc.requestBody)
			req := httptest.NewRequest(tc.method, "/events", bytes.NewBuffer(body))
			req.Header.Set("Content-Type", "application/json")

			// Create response recorder
			w := httptest.NewRecorder()

			// Call the handler
			server.handleCreateEvent(w, req)

			// Check status code
			if w.Code != tc.expectedStatus {
				t.Errorf("expected status %d, got %d", tc.expectedStatus, w.Code)
			}

			// Check response body for successful creation
			if !tc.expectedError && tc.expectedStatus == http.StatusCreated {
				var response CreateEventResponse
				if err := json.Unmarshal(w.Body.Bytes(), &response); err != nil {
					t.Errorf("failed to unmarshal response: %v", err)
				}
				if !response.Success {
					t.Errorf("expected success=true, got %v", response.Success)
				}
			}
		})
	}
}

func TestServer_HandleDeleteEvent(t *testing.T) {
	// Setup
	logger := &MockLogger{}
	app := NewMockApplication()
	server := NewServer(logger, app, ":8080")

	// Add some test events
	app.CreateEvent(context.Background(), storage.Event{ID: 1, Title: "Event 1"})
	app.CreateEvent(context.Background(), storage.Event{ID: 2, Title: "Event 2"})

	// Test cases
	testCases := []struct {
		name           string
		method         string
		eventID        string
		expectedStatus int
		expectedError  bool
	}{
		{
			name:           "successful event deletion",
			method:         http.MethodDelete,
			eventID:        "1",
			expectedStatus: http.StatusOK,
			expectedError:  false,
		},
		{
			name:           "delete non-existent event",
			method:         http.MethodDelete,
			eventID:        "999",
			expectedStatus: http.StatusInternalServerError,
			expectedError:  true,
		},
		{
			name:           "invalid event ID",
			method:         http.MethodDelete,
			eventID:        "invalid",
			expectedStatus: http.StatusBadRequest,
			expectedError:  true,
		},
		{
			name:           "wrong method",
			method:         http.MethodPost,
			eventID:        "1",
			expectedStatus: http.StatusMethodNotAllowed,
			expectedError:  true,
		},
		{
			name:           "invalid URL format",
			method:         http.MethodDelete,
			eventID:        "",
			expectedStatus: http.StatusBadRequest,
			expectedError:  true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create request URL
			url := "/api/events"
			if tc.eventID != "" {
				url += "/" + tc.eventID
			}
			req := httptest.NewRequest(tc.method, url, nil)

			// Create response recorder
			w := httptest.NewRecorder()

			// Call the handler
			server.handleSingleEvent(w, req)

			// Check status code
			if w.Code != tc.expectedStatus {
				t.Errorf("expected status %d, got %d", tc.expectedStatus, w.Code)
			}

			// Check response body for successful deletion
			if !tc.expectedError && tc.expectedStatus == http.StatusOK {
				var response DeleteEventResponse
				if err := json.Unmarshal(w.Body.Bytes(), &response); err != nil {
					t.Errorf("failed to unmarshal response: %v", err)
				}
				if !response.Success {
					t.Errorf("expected success=true, got %v", response.Success)
				}
			}
		})
	}
}

func TestServer_HandleGetEvent(t *testing.T) {
	// Setup
	logger := &MockLogger{}
	app := NewMockApplication()
	server := NewServer(logger, app, ":8080")

	// Add some test events
	app.CreateEvent(context.Background(), storage.Event{ID: 1, Title: "Event 1"})
	app.CreateEvent(context.Background(), storage.Event{ID: 2, Title: "Event 2"})

	// Test cases
	testCases := []struct {
		name           string
		method         string
		eventID        string
		expectedStatus int
		expectedError  bool
	}{
		{
			name:           "successful event retrieval",
			method:         http.MethodGet,
			eventID:        "1",
			expectedStatus: http.StatusOK,
			expectedError:  false,
		},
		{
			name:           "get non-existent event",
			method:         http.MethodGet,
			eventID:        "999",
			expectedStatus: http.StatusInternalServerError,
			expectedError:  true,
		},
		{
			name:           "invalid event ID",
			method:         http.MethodGet,
			eventID:        "invalid",
			expectedStatus: http.StatusBadRequest,
			expectedError:  true,
		},
		{
			name:           "wrong method",
			method:         http.MethodPost,
			eventID:        "1",
			expectedStatus: http.StatusMethodNotAllowed,
			expectedError:  true,
		},
		{
			name:           "invalid URL format",
			method:         http.MethodGet,
			eventID:        "",
			expectedStatus: http.StatusBadRequest,
			expectedError:  true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create request URL
			url := "/api/events"
			if tc.eventID != "" {
				url += "/" + tc.eventID
			}
			req := httptest.NewRequest(tc.method, url, nil)

			// Create response recorder
			w := httptest.NewRecorder()

			// Call the handler
			server.handleSingleEvent(w, req)

			// Check status code
			if w.Code != tc.expectedStatus {
				t.Errorf("expected status %d, got %d", tc.expectedStatus, w.Code)
			}

			// Check response body for successful retrieval
			if !tc.expectedError && tc.expectedStatus == http.StatusOK {
				var response GetEventResponse
				if err := json.Unmarshal(w.Body.Bytes(), &response); err != nil {
					t.Errorf("failed to unmarshal response: %v", err)
				}
				if !response.Success {
					t.Errorf("expected success=true, got %v", response.Success)
				}
				if response.Event.ID != 1 {
					t.Errorf("expected event ID 1, got %d", response.Event.ID)
				}
			}
		})
	}
}

func TestServer_HandleListEvents(t *testing.T) {
	// Setup
	logger := &MockLogger{}
	app := NewMockApplication()
	server := NewServer(logger, app, ":8080")

	// Add some test events
	app.CreateEvent(context.Background(), storage.Event{ID: 1, Title: "Event 1"})
	app.CreateEvent(context.Background(), storage.Event{ID: 2, Title: "Event 2"})

	// Test cases
	testCases := []struct {
		name           string
		method         string
		expectedStatus int
		expectedEvents int
	}{
		{
			name:           "successful list events",
			method:         http.MethodGet,
			expectedStatus: http.StatusOK,
			expectedEvents: 2,
		},
		{
			name:           "wrong method",
			method:         http.MethodPost,
			expectedStatus: http.StatusMethodNotAllowed,
			expectedEvents: 0,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create request
			req := httptest.NewRequest(tc.method, "/api/events", nil)

			// Create response recorder
			w := httptest.NewRecorder()

			// Call the handler
			server.handleListEvents(w, req)

			// Check status code
			if w.Code != tc.expectedStatus {
				t.Errorf("expected status %d, got %d", tc.expectedStatus, w.Code)
			}

			// Check response body for successful request
			if tc.expectedStatus == http.StatusOK {
				var response ListEventsResponse
				if err := json.Unmarshal(w.Body.Bytes(), &response); err != nil {
					t.Errorf("failed to unmarshal response: %v", err)
				}
				if !response.Success {
					t.Errorf("expected success=true, got %v", response.Success)
				}
				if len(response.Events) != tc.expectedEvents {
					t.Errorf("expected %d events, got %d", tc.expectedEvents, len(response.Events))
				}
			}
		})
	}
}
